# Описание алгоритма

Нам дан ориентированный ациклический граф (DAG). Для каждой вершины нужно посчитать значение как некоторую функцию от значений вершин, в которые из данной направлены рёбра. Из одной вершины может исходить несколько рёбер, в одну вершину может входить несколько рёбер. 

Идея алгоритма проста -- обойти граф в порядке топологической сортировки и посчитать значение для каждой вершины. Такой порядок обхода гарантирует, что когда мы собираемся вычислить значение очередной вершины, значения вершин, от которых она зависит, уже вычислены. 

Шаги алгоритма:
1. Снабдим каждую вершину счётчиком `wait_for_dependecies_count` - это количество инцидентных вершин, для которых нужно посчитать значение перед тем, как начать считать значение для данной вершины. 
2. Будем складывать очередь `wait_for_process` вершины, для которых уже можно вычислить значение. 
3. Так как граф ациклический, то гарантированно есть вершины, у которых уже задано значение. Переберём все такие вершины. Для очередной вершины `V` пройдём по всем входящим в неё рёбрам и уменьшим `wait_for_dependecies_count` на 1 для достигнутых вершин (другими словами, для каждого ребра `U -> V` мы делаем `U.wait_for_dependecies_count -= 1`). Если для какой-то вершины `wait_for_dependecies_count` стало равно нулю, значит, для этой вершины можно вычислить значение, и мы помещаем её в очередь `wait_for_process`.
4. Теперь запускаем цикл: пока в очереди `wait_for_process` есть элементы:
   1. Достаём из неё очередную вершину
   2. Считаем её значение, суммируя значения по всем исходящим рёбрам
   3. Проходим по всем входящим рёбрам и делаем то же самое, что и на шаге 3. 
5. Если очередь опустела, значит, значения для всех вершин посчитаны    

# Ход работы

## Как проводить измерения

```bash
$ for i in st mt mtb; do echo $i; time cmake-build-release/spreadsheet $i ~/Downloads/input.txt /dev/null; done
st

real	0m27,982s
user	0m2,852s
sys	0m0,210s
mt
Thread count is 12

real	0m4,290s
user	0m3,084s
sys	0m0,208s
```

## Текущий статус

MultiThreadTwoBatches работает за то же время, что и MultiThreadOne. При этом в его профиле я не вижу, чтобы треды страдали от contention - 72% времени они занимаются подсчётом значения вершины.  